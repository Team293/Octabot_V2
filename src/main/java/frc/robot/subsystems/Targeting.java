// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package frc.robot.subsystems;

import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import static frc.robot.Constants.TargetingConstants.*;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.classes.Position2D;

/**
 *
 */
public class Targeting extends SubsystemBase 
{
    private double vP = 0.001; //TODO Add these to constants and get instance of them
    private double vI = 0.0;
    private double vD = vP *10;

    private NetworkTable m_limeData;          //Data from limelight
    private NetworkTableEntry m_tAcquired;    // t stands for target
    private NetworkTableEntry m_targetX;      // x value of the target
    private NetworkTableEntry m_targetY;      // y value of the target
    private NetworkTableEntry m_targetArea;   // area of the target
    private NetworkTableEntry m_botPose;


    private double m_errorIntegral = 0.0;
    private double m_lastError = 0.0;
 
    private boolean m_isReadyToFire = false;
    
    public Targeting() 
    {
        // Get limelight data from network table
        m_limeData = NetworkTableInstance.getDefault().getTable("limelight");
        m_tAcquired = m_limeData.getEntry("tv");
        m_targetX = m_limeData.getEntry("tx");
        m_targetY = m_limeData.getEntry("ty");
        m_targetArea = m_limeData.getEntry("ta");
        m_botPose = m_limeData.getEntry("botpose");
        
        
        // Set default values for shuffleboard
        m_limeData.getEntry("camMode").setNumber(0);
        m_limeData.getEntry("ledMode").setNumber(LIMELIGHT_LED_ON);
        
        SmartDashboard.putNumber("P Gain", vP);
        SmartDashboard.putNumber("I Gain", vI);
        SmartDashboard.putNumber("D Gain", vD);
        SmartDashboard.putBoolean("isTargetted", false);
    }

    @Override
    public void periodic() 
    {
        SmartDashboard.putNumber("Tx", m_targetX.getDouble(10000));
        SmartDashboard.putNumber("Ty", m_targetY.getDouble(10000));
        SmartDashboard.putNumberArray("pose", m_botPose.getDoubleArray(new Double[1]));
    }

    public boolean getIsReadyToFire()
    {
        return m_isReadyToFire;
    }

    // Turns the LED on or off
    public void controlLight(boolean enabled)
    {
        if(enabled)
        {
            m_limeData.getEntry("ledMode").setNumber(LIMELIGHT_LED_ON); 
        }
        else
        {
            m_limeData.getEntry("ledMode").setNumber(LIMELIGHT_LED_OFF);
        }
    }

    public double navToTarget()
    {
        double percentOutput = 0.0d;

        //Do we have a target?
        if (m_tAcquired.getDouble(TARGET_NO_TARGET) == TARGET_ACQUIRED)
        {
            double limeError = m_targetX.getDouble(0.0); //Get the error of the target X
            double headingError = limeError ; // 29.5 is the range of the limelight which goes from -29.5 to 29.5 
            double change = headingError - m_lastError;

            //Is this still used? INTEGRAL_LIMIT is the same as CONFIRMED_THRESHOLD
            if(Math.abs(m_errorIntegral) < INTEGRAL_LIMIT) 
            {
                //Accumulate the error into the integral
                m_errorIntegral += headingError * INTEGRAL_WEIGHT;
                SmartDashboard.putNumber("Integral", m_errorIntegral);
            }
            
            //Calculate percent output to feed to velocity drive
            percentOutput = (vP * headingError) + (vI * m_errorIntegral) + (vD * change);

            clampPercentOutput(percentOutput);
           
            
            //Save last error
            m_lastError = headingError;
        }
        
        return percentOutput;
    }

    private double clampPercentOutput(double percent){
        if(percent > PERCENT_OUTPUT_LIMIT) 
        {
            percent = PERCENT_OUTPUT_LIMIT;
        }
        else if(percent < -PERCENT_OUTPUT_LIMIT) 
        {
            percent = -PERCENT_OUTPUT_LIMIT;
        }

        return percent;
    }
    
    public double calcShooterRPM()
    {
        double retval = 0.0;
        if(m_tAcquired.getDouble(0.0) == TARGET_ACQUIRED)
        {
            //This is where we would calculate the distance
            retval = DEFAULT_LAUNCHER_RPM;
        }

        return retval;
    }

    public void resetPID()
    {
        m_errorIntegral = ERROR_INTEGRAL_DEFAULT;
        m_lastError = LAST_ERROR_DEFAULT;
    }

    public boolean isTargetted(){
        boolean targeted = false;
        double limeError = m_targetX.getDouble(0.0); //Get the error of the target X

        if(Math.abs(limeError) < CONFIRMED_THRESHOLD) 
        {
            targeted = true;
        }
        
        return targeted;
    }

    public double calcDistance(){
        double targetOffsetAngle_Vertical = m_targetY.getDouble(0.0);
        double limelightMountAngleDegrees = 26.742; 
        double limelightLensHeightInches = 11.5; 
        double goalHeightInches = 104.0; 
        
        double angleToGoalDegrees = limelightMountAngleDegrees + targetOffsetAngle_Vertical; 
        double angleToGoalRadians = Math.toRadians(angleToGoalDegrees); 
        double distanceFromLimelightToGoalInches = (goalHeightInches - limelightLensHeightInches)/Math.tan(angleToGoalRadians);

        return distanceFromLimelightToGoalInches; 
    }

    public double getTargetArea(){
        return m_targetArea.getDouble(-1.0);
    }
    public boolean hasTarget(){
        return m_tAcquired.getDouble(-1) == 1;
    }

    public Position2D getRobotPose(){
        Double[] pose = m_botPose.getDoubleArray(new Double[1]);
        return new Position2D(pose[0].doubleValue() * 3.28, pose[1].doubleValue() * 3.28, pose[2].doubleValue() * 3.28); // TODO check if indexes are correct
    }
}