// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import edu.wpi.first.wpilibj.I2C.Port;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.classes.Kinematics;
import frc.robot.classes.Position2D;
import frc.robot.classes.SPIKE293Utils;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.kauailabs.navx.frc.AHRS;
import static frc.robot.Constants.DrivetrainConstants.*;
import frc.robot.classes.spikemotor.*;

public class Drivetrain extends SubsystemBase {
    private SpikeMotor leftTalonLead;
    private SpikeMotor rightTalonLead;
    private AHRS navX;
    private Kinematics m_kinematics;
    
    private static final double WHEEL_DIAMETER = 3.75 / 12.0; // Wheel diameter in feet

    public Drivetrain(Kinematics kinematics) {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        leftTalonLead = new SpikeMotorTalonFX(WHEEL_DIAMETER, true);
        leftTalonLead.init(LEFT_LEAD_TALON_CAN_ID);
        rightTalonLead = new SpikeMotorTalonFX(WHEEL_DIAMETER, false);
        rightTalonLead.init(RIGHT_LEAD_TALON_CAN_ID);

        navX = new AHRS(Port.kMXP);
        setupGyro(navX, 0.0d);
        zeroDriveTrainEncoders();
        m_kinematics = kinematics;
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        // Put code here to be run every loop
        // Run Kinematics
        if (USE_NAVX_HEADING) {
            // use the NAVX for heading
            double headingInRadians = Math.toRadians(getGyroHeadingDegrees());
            m_kinematics.calculatePosition(getLeftEncoderPosition(), getRightEncoderPosition(), headingInRadians);
        } else {
            // Use the encoder information for heading
            m_kinematics.calculatePosition(getLeftEncoderPosition(), getRightEncoderPosition());
        }

        // Get current pose from Kinematics
        Position2D currentPose = m_kinematics.getPose();

        // Push robot info to Dashboard
        SmartDashboard.putNumber("Kinematics X (Feet)", currentPose.getX());
        SmartDashboard.putNumber("Kinematics Y (Feet)", currentPose.getY());
        SmartDashboard.putNumber("Kinematics Heading (degrees)", currentPose.getHeadingDegrees());

        SmartDashboard.putNumber("Left Encoder Velocity (Ft/S)", getLeftEncoderVelocity());
        SmartDashboard.putNumber("Left Encoder Position (Ft)", getLeftEncoderPosition());
        SmartDashboard.putNumber("Right Encoder Velocity (Ft/S)", getRightEncoderVelocity());
        SmartDashboard.putNumber("Right Encoder Position (Ft)", getRightEncoderPosition());
        // SmartDashboard.putNumber("Raw Left Encoder", leftTalonLead.getSelectedSensorPosition(0));
        // SmartDashboard.putNumber("Raw Right Encoder", rightTalonLead.getSelectedSensorPosition(0));

        SmartDashboard.putNumber("Robot Heading (degrees)", getGyroHeadingDegrees());
        SmartDashboard.putNumber("NavX X Accel", navX.getWorldLinearAccelX());
        SmartDashboard.putNumber("NavX Y Accel", navX.getWorldLinearAccelY());
        SmartDashboard.putNumber("NavX Z Accel", navX.getWorldLinearAccelZ());
        SmartDashboard.putNumber("NavX Yaw", getGyroYawDegrees());
        SmartDashboard.putNumber("NavX Angle", getGyroHeadingDegrees());
        SmartDashboard.putNumber("NavX Fused Heading", getGyroFusedHeadingDegrees());
        SmartDashboard.putNumber("NavX TurnRate dg/s", navX.getRate());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void percentDrive(double leftPercentage, double rightPercentage) {
        double maxVelocity = 1.0; // in ft/sec
        leftTalonLead.setSpeed(leftPercentage * maxVelocity);
        rightTalonLead.setSpeed(rightPercentage * maxVelocity);
    }

    public void stop() {
        leftTalonLead.setSpeed(0);
        rightTalonLead.setSpeed(0);
    }

    // Sets the motors to encoder units per desisec (100ms), uses the onboard motor
    // PID
    public void velocityDrive(double vL, double vR) {
        SmartDashboard.putNumber("Set Velocity Left (Encoder units/100ms)", vL);
        SmartDashboard.putNumber("Set Velocity Right (Encoder units/100ms)", vR);
        leftTalonLead.setSpeed(vL);
        rightTalonLead.setSpeed(vR);
    }

    public void resetGyro(double headingDegrees) {
        setupGyro(navX, headingDegrees);
    }

    /**
     * returns left encoder position
     * 
     * @return left encoder position
     */
    public double getLeftEncoderPosition() {
        // Returns the number of steps, multiply by edges per step to get EPR, divided
        // by the gearbox ratio
        return leftTalonLead.getPosition();
    }

    /**
     * returns right encoder position
     * 
     * @return right encoder position
     */
    public double getRightEncoderPosition() {
        // Returns the number of steps, multiply by edges per step to get EPR, divided
        // by the gearbox ratio
        return rightTalonLead.getPosition();
    }

    /**
     * returns left encoder Velocity in ft/s
     * 
     * @return left encoder Velocity in ft/s
     */
    public double getLeftEncoderVelocity() {
        // Returns the velocity of encoder by claculating the velocity from encoder
        // units of click/100ms to ft/s
        return leftTalonLead.getSpeed();
    }

    /**
     * returns right encoder Velocity in ft/s
     * 
     * @return right encoder Velocity in ft/s
     */
    public double getRightEncoderVelocity() {
        // Returns the velocity of encoder by claculating the velocity from encoder
        // units of click/100ms to ft/s
        return rightTalonLead.getSpeed();
    }

    /**
     * returns robot Velocity in ft/s
     * 
     * @return robot Velocity in ft/s
     */
    public double getRobotVelocity() {
        // Returns the velocity of the robot by taking the averga of the velcity on both
        // sides of the robor
        return (getLeftEncoderVelocity() + getRightEncoderVelocity()) / 2.0d;
    }

    /**
     * resets the drive train encoders to 0
     */
    private void zeroDriveTrainEncoders() {
        leftTalonLead.setPosition(0);
        rightTalonLead.setPosition(0);
    }

    public double getGyroFusedHeadingDegrees() {
        return (navX.getFusedHeading() * -1.0d);
    }

    public double getGyroYawDegrees() {
        return (navX.getYaw() * -1.0d);
    }

    public double getGyroHeadingDegrees() {
        return (navX.getAngle() * -1.0d);
    }

    public void setupGyro(AHRS gyro, double startingAngleDegrees) {

        System.out.println("Calibrating gyroscope.");

        gyro.enableBoardlevelYawReset(true);
        gyro.reset();
        gyro.calibrate();

        // Wait for gyro to calibrate ~1 - 10 seconds
        while (gyro.isCalibrating()) {
        }

        // Set's the starting angle to the given angle
        gyro.setAngleAdjustment(startingAngleDegrees);

        System.out.println("Calibrating gyroscope done.");
    }

    public void resetKinematics() {
        setupGyro(navX, 0.0d);
        zeroDriveTrainEncoders();
    }

}